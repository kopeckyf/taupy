Experiments: Simulations in parallel
====================================

There isn't much fun in entering every argument yourself: debate simulations can
take hundreds of steps before coming to an end. Also, for most research questions
you probably want to run more than one simulation to make sure you haven't ended up
with an outlier. The :py:func:`taupy.experiment` function provides for all of these
needs.

.. code:: python
    
    # First, create 10 positions with strategy random
    positions = [Position(debate=None, introduction_strategy=strategies.random) for _ in range(10)]
    
    # Run 4 simulations in an experiment (multi-threaded!):
    my_experiments = experiment(n=4,
                                simulations={"positions": positions,
                                             "sentencepool": "p:10",
                                             "argumentlength": [2,3]},
                                runs={"max_density": 0.8,
                                      "max_steps": 200}
                                )

This creates an object :py:obj:`my_experiments` with four elements: :py:obj:`my_experiments[0]`
contains the first simulation, the second is in :py:obj:`my_experiments[1]`, etc.

The dictionary in the `simulations` argument contains the arguments for creation of the 
:py:obj:`Simulation` object. So the above call to :py:func:`taupy.experiment` creates
simulation object :py:obj:`s` that look like this:

.. code:: python

    s = Simulation(positions=positions, sentencepool="p:10", "argumentlength"=[2,3])
    

And the directives in the dictionary `runs` are arguments to the method `Simulation.run()`
which is called by the experiments. So the setting above are equivalent to:

.. code:: python

    s.run(max_density=0.8, max_steps=200)
    
For each simulation :py:obj:`s` of the four generated by the experiment.
